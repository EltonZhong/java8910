# toycode


理一下思路：同步异步在编程上与IO上是不一样的。

关于编程：

同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)
所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
换句话说，就是由*调用者*主动等待这个*调用*的结果。

而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

典型的异步编程模型比如Node.js

而阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.



关于IO：
IO中的同步是指 自IO操作的发起到数据被拷贝到内核态之后， 就需要用户进程参与将数据从内核态拷贝到用户态。而异步是指IO操作请求发起之后， 内核态与用户态的数据拷贝不需要用户进程参与。
按照《Unix网络编程》的划分，IO模型可以分为：阻塞IO、非阻塞IO、IO复用、信号驱动IO和异步IO，
按照POSIX标准来划分只分为两类：同步IO和异步IO。

如何区分呢？

首先一个IO操作(read/write系统调用)其实分成了两个步骤：1)发起IO请求和2)实际的IO读写(内核态与用户态的数据拷贝)

阻塞IO和非阻塞IO的区别在于第一步，发起IO请求的进程是否会被阻塞，如果阻塞直到IO操作完成才返回那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。

同步IO和异步IO的区别就在于第二步，实际的IO读写(内核态与用户态的数据拷贝)是否需要进程参与，如果需要进程参与则是同步IO，如果不需要进程参与就是异步IO。

如果实际的IO读写需要请求进程参与，那么就是同步IO。因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，

使用了特使api如linux 的AIO 的程序才实现了异步IO， 而select， epoll之类都是同步IO
在编程上，这种非阻塞IO一般都采用IO状态事件+回调方法的方式来处理IO操作。
如果是同步IO，则状态事件为读写就绪。此时的数据仍在内核态中，但是已经准备就绪，可以进行IO读写操作。
如果是异步IO，则状态事件为读写完成。此时的数据已经存在于应用进程的地址空间（用户态）中。

看到一篇答案是 写的最清楚的:
https://www.zhihu.com/question/19732473/answer/88599695
